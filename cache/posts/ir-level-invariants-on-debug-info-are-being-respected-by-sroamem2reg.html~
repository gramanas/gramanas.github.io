<div id="outline-container-orgedc8a40" class="outline-2">
<h2 id="orgedc8a40">Intorduction</h2>
<div class="outline-text-2" id="text-orgedc8a40">
<p>
The past weeks the efforts were focused around the Scalar Replacement of
Aggregates pass. This is an early stage pass and thus the amount of debug
info loss should be minimized cause it impacts the whole compiler a lot more.
</p>

<p>
Our contribution has been to systematically show that IR-level 
invariants on debug info are being respected by SROA/mem2reg.
</p>

<p>
The debugify pass with the newly implemeted debugify-each[] option was the
main tool used.
</p>
</div>
</div>

<div id="outline-container-org1f67924" class="outline-2">
<h2 id="org1f67924">Proccess</h2>
<div class="outline-text-2" id="text-org1f67924">
<ul class="org-ul">
<li>Run sroa through samples of IR</li>
</ul>
<div class="highlight"><pre><span></span> opt -debugify -sroa -check-debugify <span class="o">{</span>ir_file.ll<span class="o">}</span>
</pre></div>
<ul class="org-ul">
<li>When finding errors I created a reduecd IR test case like <a href="https://reviews.llvm.org/D47097">here</a> and <a href="https://reviews.llvm.org/D47720">here</a>.</li>
<li>Fix the failing tests</li>
</ul>
</div>
</div>

<div id="outline-container-org4e5f033" class="outline-2">
<h2 id="org4e5f033">Results</h2>
<div class="outline-text-2" id="text-org4e5f033">
<p>
I made a <a href="https://gramanas.github.io/posts/sroa-on-amalgamated-sqlite-source/">report</a> after runing SROA on the amalgamated sqlite source.
The results were a clear indication that SROA was doing it's job just fine
and the little instructions without DebugLoc were produced from clang and it
wasn't SROA/mem2reg's fault.
</p>

<p>
After applying the above clang patches the results are even better.
</p>
</div>
</div>

<div id="outline-container-orga1801f6" class="outline-2">
<h2 id="orga1801f6">Comparing the results to <a href="https://llvm.org/devmtg/2018-04/slides/Bedwell-Measuring_the_User_Debugging_Experience.pdf">dexter</a> ones</h2>
<div class="outline-text-2" id="text-orga1801f6">
<p>
Dexter scored SROA low.
</p>

<p>
As Greg (dexter's creator) mentions the dexter results don't have
to indicate that there is some kind of bug
</p>

<blockquote>
<p>
The methodology I used is with the opt-bisect-limit option on clang, so
it's not strictly the case that the results presented show that the loss in
"debugability" occurs during the SROA pass itself directly but rather that
the effect of running SROA is some loss in debugability to the final
program.  I didn't make that point clear enough during my lightning talk
session!
</p>
</blockquote>

<p>
And such is the case with SROA.
</p>

<p>
A <a href="https://bugs.llvm.org/show_bug.cgi?id=37682">bug report</a> has been filed explaining the problem.
</p>

<p>
Basically after running SROA/mem2reg the optimizations will
at many cases result in weird stepping behavior in the debugger.
This is normal since that's the whole point of passes like SROA and
LICM: to reduce the instructions by optimizing aggregates and loops.
</p>

<p>
This is bad from the debug prespective and thus scores low on dexter.
</p>
</div>
</div>
