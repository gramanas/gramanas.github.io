<p>
Less than a week remains until the coding period officialy starts.
Since the last post a few things changed. For starters I didn't
get to implement the debugify-each mode cause someone else 
already had a semi working implementation for it, witch
recently landed for <a href="https://reviews.llvm.org/D46525">reviews</a>.
</p>

<p>
Meanwhile using data from a <a href="https://llvm.org/devmtg/2018-04/talks.html#Lightning_11">talk</a> given earlier this year 
we figured that SROA reports a lot of DI Loss occurencies and debugify confirms that.
It's also pretty eraly in the pipeline, so it's even more important.
So, I've been reading through the code and learning about it. A great help
has been <a href="https://gcc.gnu.org/wiki/summit2010?action=AttachFile&do=get&target=jambor.pdf">this</a> paper which tries to explain the goals of the
scalar replacement of aggregates.
</p>

<p>
SORA is a big and complicated pass. I found this <a href="https://lists.llvm.org/pipermail/llvm-dev/2012-August/052682.html">mail</a> from way back
then from Chandler Carruth (who rewrote the pass to it's current form),
that explains the basic underlying logic of the partitioning and splitting
that takes place in the algorithm.
</p>

<p>
There is still a lot left for me to begin to understand how the pass works,
and in a way of doing that I've been trying hunt down when the following DI loss occures:
</p>

<p>
<code>Before SROA</code>
</p>
<div class="highlight"><pre><span></span>entry:
  %a.addr = alloca i32, align 4
  %n.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store i32 %a, i32* %a.addr, align 4, !tbaa !9
  store i32 %n, i32* %n.addr, align 4, !tbaa !9
  %0 = bitcast i32* %i to i8*, !dbg !13
  call void @llvm.lifetime.start(i64 4, i8* %0) #2, !dbg !13
  store i32 0, i32* %i, align 4, !dbg !14, !tbaa !9
  br label %for.cond, !dbg !13

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %i, align 4, !dbg !15, !tbaa !9
  %2 = load i32, i32* %n.addr, align 4, !dbg !17, !tbaa !9
  %cmp = icmp slt i32 %1, %2, !dbg !18
  br i1 %cmp, label %for.body, label %for.cond.cleanup, !dbg !19
</pre></div>

<p>
<code>After SROA</code>
</p>
<div class="highlight"><pre><span></span>entry:
  br label %for.cond, !dbg !9

for.cond:                                         ; preds = %for.inc, %entry
  %a.addr.0 = phi i32 [ %a, %entry ], [ %0, %for.inc ]
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ], !dbg !10
  %cmp = icmp slt i32 %i.0, %n, !dbg !12
  br i1 %cmp, label %for.body, label %for.cond.cleanup, !dbg !14
</pre></div>

<p>
Notice the missing DI in the first Ï† instruction of the <code>for.cond</code> block.
</p>

<p>
I am still very disoriented in the codebase and am trying to understand how things
interact with each other.
</p>
